@rendermode InteractiveServer

<div class="transition-container">
    <div class="fade-content @(hasSelectedBlindTimer ? "visible" : "hidden")">
        <div class="py-4 px-6 mx-4 rounded-xl" style="background-color: black; color: white; margin-top: 20px; margin-bottom: 20px;">
            <MudText style="font-size: 7em;">
                @TimeDisplay
            </MudText>
        </div>
    </div>

    <div class="fade-content @(hasSelectedBlindTimer ? "hidden" : "visible")">
        <div class="py-4 px-6 mx-4 rounded-xl" style="background-color: #F2F7F4; color: black; margin-top: 20px; margin-bottom: 20px;">
            <span style="font-size: 2em;"># minute blinds:</span>
            
            <MudRadioGroup T="int" class="pa-7" @bind-Value="SelectedBlindTimerInSeconds">
                <MudRadio Color="Color.Primary" UncheckedColor="Color.Default" Value="600">10</MudRadio>
                <MudRadio Color="Color.Primary" UncheckedColor="Color.Default" Value="900">15</MudRadio>
                <MudRadio Color="Color.Primary" UncheckedColor="Color.Default" Value="1200">20</MudRadio>
                <MudRadio Color="Color.Primary" UncheckedColor="Color.Default" Value="1800">30</MudRadio>
                <MudRadio Color="Color.Primary" UncheckedColor="Color.Default" Value="2700">45</MudRadio>
                <MudRadio Color="Color.Primary" UncheckedColor="Color.Default" Value="3600">60</MudRadio>
                <MudRadio Color="Color.Primary" UncheckedColor="Color.Default" Value="5">5 seconds (demo)</MudRadio>
            </MudRadioGroup>
        </div>
    </div>
</div>

@code {
    private string TimeDisplay => $"{remainingSeconds / 60:D2}:{remainingSeconds % 60:D2}";

    private bool hasSelectedBlindTimer => SelectedBlindTimerInSeconds > 0;


    [Parameter]
    public EventCallback OnTimerHitZero { get; set; }

    [Parameter]
    public int SelectedBlindTimerInSeconds
    {
        get => field;
        set
        {
            if (field != value)
            {
                field = value;
                remainingSeconds = value; 
                SelectedBlindTimerInSecondsChanged.InvokeAsync(value);
                StateHasChanged();       
            }
        }
    }

    [Parameter]
    public EventCallback<int> SelectedBlindTimerInSecondsChanged { get; set; }

    [Parameter]
    public bool CountdownIsRunning { get; init; }

    private bool _previousCountdownState;

    // Called whenever a parent updates any of this component's [Parameter] values.
    // This is used to avoid calling async methods in a property's setter, which is a big no-no clean-architecture-wise
    protected override async Task OnParametersSetAsync()
    {
        if (CountdownIsRunning != _previousCountdownState)
        {
            _previousCountdownState = CountdownIsRunning;

            if (CountdownIsRunning)
                await StartCountdown();
            else
                StopCountdown();
        }
    }


    private int remainingSeconds; 
    private bool isRunning = false;

    public async Task StartCountdown()
    {
        isRunning = true;

        if (!hasSelectedBlindTimer)
        {
            return;
        }

        while (remainingSeconds > 0 && isRunning)
        {
            // Previously this used a Timer but that caused issues with different threads trying to fire events. This is shorter & simpler.
            remainingSeconds--;
            StateHasChanged();
            await Task.Delay(1000);
        }

        if (isRunning)
        {
            // notify parent component that the timer hit zero
            await OnTimerHitZero.InvokeAsync();

            // Reset the timer
            remainingSeconds = SelectedBlindTimerInSeconds;
            await StartCountdown();
        }
    }

    public void StopCountdown() => isRunning = false;

}
